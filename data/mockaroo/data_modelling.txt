1.
To begin with, the Mockaroo developers allowed for a very narrow range of names.
They didn't consider the possibility that people can have more than one full
name or more than one first or last name. This is especially common in other
cultures such as those in Portugal, Spain, Nigeria, and many indigenous cultures.
On the other hand, some people may not even have a last name. Including a field
for last name that can be left blank leaves it unclear whether the last name
is unknown or the person has no last name. Furthermore, they assumed that all
people's names can be written with letters of the English language, which is
clearly untrue. Characters in other languages like Chinese, Japanese, Hindi, and
many more are are entirely unaccounted for. Overall, the Mockaroo names
generated are only representative of a subset of names in English-speaking
countries.

Another field that the Mockaroo developers did not fully consider is the
street address. All of the addresses generated included some kind of number,
whether it consisted of just a single digit or multiple. However, not all
address need to include a building number and when they do, it doesn't have
to be all-numeric. It also doesn't account for symbols like commas, brackets,
hyphens, dots, and more in the middle of the address. Since this form of
writing addresses may be popular in other countries, it prevents people in many
foreign countries from having their addresses recorded.

2.
In general, I tried to make my decisions as broad as possible while still
restricting the format of the date, email, and gender fields a little so as
to conform with the data generated by Mockaroo. The data can only be provided in
a format consisting of 1 or 2 numbers followed by a forward slash then 1 or 2
more numbers, another forward slash, and 4 numbers. However, this problem
can be dealt with by the frontend by only providing the user with options to
enter a date in this format. In the case that a date not in this format
enters the program, a message saying "Unrecognized date format" is simply
printed out for the date field. This, however, is different from the message
printed out if the date field is null which is "Unknown." I made this distinction
in my program so that it was clear whether the date was not provided or if it
was provided and could be a potential date but the program didn't recognize it
as one.

The email is restricted to any set of Unicode characters followed by the @
symbol followed by any set of Unicode characters. This is because all email
addresses must have an @ symbol somewhere within them as defined in RFC 5322
and RFC 5321. However,not all email addresses must have the . symbol at some
point following the @ symbol (it is highly encouraged though). Thus, I only
checked for the @ symbol. This, however, means the system won't accept extremely
old email addresses which were not required to have the @ symbol. Once again,
the program differentiates between an "Unrecognized email" and one that is
"Unknown" in order to make it clear that even an email without an @ symbol
may potentially be a valid email address.

Finally, the gender is restricted to the English alphabet (lowercase and
uppercase). I made this decision to prevent the entering of too many different
genders that may be synonyms for the same thing. Also, allowing any language
for this field may lead to lots of potential confusion since different
languages may have different phrases to convey the same gender as defined in
English. The gender field too would be dealt with by the frontend by only
allowing the user to type in either lowercase or uppercase English letters. A
potential problem with this is that it limits genders to those that the
English language recognizes which may not cover all of them, especially
since different languages and cultures may have different concepts of gender.

3.
I made my REPL extensible by using a command pattern. THe REPL simply acts
to instantiate a TriggerActionExecutor which is the invoker of the TriggerAction
interface, the command interface. This interface simply defines an execute
method for any class that implements it. Since all the commands implement the
TriggerAction interface, each of them has an execute method and thus, it is
possible to run the correct command even though the REPL itself has no
knowledge of which class has the correct method to run. Thus, taking in any
type of command is very easy. The command doesn't need to relate to stars at all
and doesn't need to print anything out. It simply needs to implement the
TriggerAction interface and define an execute method. Essentially, this uses
the inversion of control principle from the reading to pass in an existing
instance of a class that implements the TriggerAction interface to the
TriggerActionExecutor. It also uses the idea of composition to break apart
the REPL problem into much smaller classes that each have their own function.

There are a few ways I could make my REPL even more extensible. Right now, it
separates all commands based on spaces and excluding spaces between quotes.
However, the user may want to specify how to divide the commands using a
REGEX expression. For example, they may want to use commas to separate each
of the arguments instead. I could add a parameter to the REPL to allow this to
give the user more control over how the commands and arguments entered are
parsed. In addition, the REPL currently gives the user no control over how
errors are handled. In some cases, I may want to throw the error out of the REPL
or handle it in a different way than simply printing out an error message.
Other than this, however, I believe my REPL can easily be extended to many
different commands and many different scenarios.
